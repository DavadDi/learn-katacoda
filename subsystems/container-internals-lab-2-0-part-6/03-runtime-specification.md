# The Runtime Specification

This specification governs the format of the file that is passed to container runtime. This is typically runc, but every OCI compliant runtime will accept this file format (Examples: Kata, gVisor, etc). Typically, this file is constructed by a container engine such as CRI-O, Podman, or the Docker engine. These files can be created manually, but it's a tedious process. Instead, we are going to do couple of experiments so that you can get a feel for this file without having to create one manually. 

The runc tool, which is the OCI reference implementation of a [Container Runtime](https://developers.redhat.com/blog/2018/02/22/container-terminology-practical-introduction/#h.6yt1ex5wfo55), has the ability to create a very simple spec file. Create one and take a quick look at the fairly simple set of directives:

``runc spec
cat config.json``{{execute}}

Now, lets steal a more complex file from podman. Create a long running container (aka like a daemon or service):

``podman run -dt fedora bash``{{execute}}

Now, lets steal the config.json which Podman created. Again, this file is a combination of inputs from the:

1. The container repository, the config.json which we inspected before. Think of this as a set of defaults that are created by the image builder. They are a combination of user inputs (Example: CMD) and defaults specified by the build tool (Example: Architecture)

2. The container engine itself. Some of these can be configured in the configuration for the container engine (Example: SECCOMP profiles), some are dynamically generated by the container engine (Example: sVirt/SELinux contexts, or Bind Mounts - aka the copy on write layer which gets mounted in the container's namespace), while others are hardcoded in the engine (Example: the default namespaces to utilize).

3. The command line options specified by the user of the container engine (or robot in Kubernetes' case). Some of these are simple things like Bind mounts (Example: -v /data:/data) or more complex like security options (Example: --privileged which disables a lot of technologies in the kernel). 

Take a look at this example config.json in all of its glory. See if you can spot directives which come from the container repository, the engine, and the user:

``cat $(find /var/lib/containers/ | grep  $(podman ps --no-trunc -q | tail -n 1)/userdata/config.json)``{{Execute}}

Now that we have a basic understanding, lets move on to starting a container...
